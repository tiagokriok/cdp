package aliases

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// ShellType represents the type of shell
type ShellType string

const (
	Bash ShellType = "bash"
	Zsh  ShellType = "zsh"
	Fish ShellType = "fish"
)

const (
	aliasBlockStart = "# cdp-aliases-start"
	aliasBlockEnd   = "# cdp-aliases-end"
)

// AliasManager handles shell alias operations
type AliasManager struct {
	shellType ShellType
	rcFile    string
}

// New creates a new AliasManager by detecting the current shell
func New() (*AliasManager, error) {
	shell := os.Getenv("SHELL")
	if shell == "" {
		return nil, fmt.Errorf("SHELL environment variable not set")
	}

	homeDir, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("failed to get home directory: %w", err)
	}

	var shellType ShellType
	var rcFile string

	shellBase := filepath.Base(shell)
	switch {
	case strings.Contains(shellBase, "zsh"):
		shellType = Zsh
		rcFile = filepath.Join(homeDir, ".zshrc")
	case strings.Contains(shellBase, "fish"):
		shellType = Fish
		rcFile = filepath.Join(homeDir, ".config", "fish", "config.fish")
	default:
		shellType = Bash
		rcFile = filepath.Join(homeDir, ".bashrc")
	}

	return &AliasManager{
		shellType: shellType,
		rcFile:    rcFile,
	}, nil
}

// NewWithShell creates an AliasManager for a specific shell type
func NewWithShell(shellType ShellType) (*AliasManager, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("failed to get home directory: %w", err)
	}

	var rcFile string
	switch shellType {
	case Zsh:
		rcFile = filepath.Join(homeDir, ".zshrc")
	case Fish:
		rcFile = filepath.Join(homeDir, ".config", "fish", "config.fish")
	default:
		rcFile = filepath.Join(homeDir, ".bashrc")
	}

	return &AliasManager{
		shellType: shellType,
		rcFile:    rcFile,
	}, nil
}

// GetShellType returns the detected shell type
func (am *AliasManager) GetShellType() ShellType {
	return am.shellType
}

// GetRCFile returns the path to the RC file
func (am *AliasManager) GetRCFile() string {
	return am.rcFile
}

// InstallAliases installs aliases for the given profiles
func (am *AliasManager) InstallAliases(profiles map[string]string) error {
	// Read existing content
	content, err := am.readRCFile()
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to read RC file: %w", err)
	}

	// Remove existing cdp aliases block
	content = am.removeAliasBlock(content)

	// Generate new aliases block
	aliasBlock := am.generateAliasBlock(profiles)

	// Append new block
	if !strings.HasSuffix(content, "\n") && content != "" {
		content += "\n"
	}
	content += aliasBlock

	// Write back
	if err := am.writeRCFile(content); err != nil {
		return fmt.Errorf("failed to write RC file: %w", err)
	}

	return nil
}

// UninstallAliases removes all cdp aliases from the RC file
func (am *AliasManager) UninstallAliases() error {
	content, err := am.readRCFile()
	if err != nil {
		if os.IsNotExist(err) {
			return nil // Nothing to uninstall
		}
		return fmt.Errorf("failed to read RC file: %w", err)
	}

	content = am.removeAliasBlock(content)

	if err := am.writeRCFile(content); err != nil {
		return fmt.Errorf("failed to write RC file: %w", err)
	}

	return nil
}

// ListAliases returns the currently installed aliases
func (am *AliasManager) ListAliases() (map[string]string, error) {
	content, err := am.readRCFile()
	if err != nil {
		if os.IsNotExist(err) {
			return map[string]string{}, nil
		}
		return nil, fmt.Errorf("failed to read RC file: %w", err)
	}

	return am.parseAliases(content), nil
}

// IsInstalled checks if cdp aliases are installed
func (am *AliasManager) IsInstalled() bool {
	content, err := am.readRCFile()
	if err != nil {
		return false
	}
	return strings.Contains(content, aliasBlockStart)
}

// generateAliasBlock generates the alias block for the RC file
func (am *AliasManager) generateAliasBlock(profiles map[string]string) string {
	var sb strings.Builder

	sb.WriteString("\n")
	sb.WriteString(aliasBlockStart)
	sb.WriteString("\n")
	sb.WriteString("# Auto-generated by cdp - DO NOT EDIT THIS BLOCK\n")

	for profile, shortcut := range profiles {
		if am.shellType == Fish {
			sb.WriteString(fmt.Sprintf("alias %s='cdp %s'\n", shortcut, profile))
		} else {
			sb.WriteString(fmt.Sprintf("alias %s='cdp %s'\n", shortcut, profile))
		}
	}

	sb.WriteString(aliasBlockEnd)
	sb.WriteString("\n")

	return sb.String()
}

// removeAliasBlock removes the cdp alias block from content
func (am *AliasManager) removeAliasBlock(content string) string {
	startIdx := strings.Index(content, aliasBlockStart)
	if startIdx == -1 {
		return content
	}

	endIdx := strings.Index(content, aliasBlockEnd)
	if endIdx == -1 {
		return content
	}

	// Include the newline after the end marker
	endIdx += len(aliasBlockEnd)
	if endIdx < len(content) && content[endIdx] == '\n' {
		endIdx++
	}

	// Also remove the newline before the start marker
	if startIdx > 0 && content[startIdx-1] == '\n' {
		startIdx--
	}

	return content[:startIdx] + content[endIdx:]
}

// parseAliases extracts aliases from the cdp block
func (am *AliasManager) parseAliases(content string) map[string]string {
	aliases := make(map[string]string)

	startIdx := strings.Index(content, aliasBlockStart)
	if startIdx == -1 {
		return aliases
	}

	endIdx := strings.Index(content, aliasBlockEnd)
	if endIdx == -1 {
		return aliases
	}

	block := content[startIdx:endIdx]
	scanner := bufio.NewScanner(strings.NewReader(block))

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "alias ") {
			// Parse: alias shortcut='cdp profile'
			parts := strings.SplitN(line, "=", 2)
			if len(parts) == 2 {
				shortcut := strings.TrimPrefix(parts[0], "alias ")
				shortcut = strings.TrimSpace(shortcut)

				value := strings.Trim(parts[1], "'\"")
				if strings.HasPrefix(value, "cdp ") {
					profile := strings.TrimPrefix(value, "cdp ")
					aliases[shortcut] = profile
				}
			}
		}
	}

	return aliases
}

// readRCFile reads the RC file content
func (am *AliasManager) readRCFile() (string, error) {
	data, err := os.ReadFile(am.rcFile)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// writeRCFile writes content to the RC file
func (am *AliasManager) writeRCFile(content string) error {
	// Ensure parent directory exists (for fish)
	dir := filepath.Dir(am.rcFile)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}
	return os.WriteFile(am.rcFile, []byte(content), 0644)
}

// GenerateDefaultAliases generates default short aliases for profiles
func GenerateDefaultAliases(profileNames []string) map[string]string {
	aliases := make(map[string]string)

	for _, name := range profileNames {
		// Generate short alias: first letter or first 2-3 chars
		shortcut := generateShortcut(name, aliases)
		aliases[name] = shortcut
	}

	return aliases
}

// generateShortcut creates a unique shortcut for a profile name
func generateShortcut(name string, existing map[string]string) string {
	// Collect existing shortcuts
	usedShortcuts := make(map[string]bool)
	for _, shortcut := range existing {
		usedShortcuts[shortcut] = true
	}

	// Try single letter first
	firstLetter := strings.ToLower(string(name[0]))
	if !usedShortcuts["c"+firstLetter] {
		return "c" + firstLetter // cw for work, cp for personal, etc.
	}

	// Try first two letters
	if len(name) >= 2 {
		twoLetters := "c" + strings.ToLower(name[:2])
		if !usedShortcuts[twoLetters] {
			return twoLetters
		}
	}

	// Try first three letters
	if len(name) >= 3 {
		threeLetters := "c" + strings.ToLower(name[:3])
		if !usedShortcuts[threeLetters] {
			return threeLetters
		}
	}

	// Fallback: use full name with c prefix
	return "c" + strings.ToLower(name)
}
